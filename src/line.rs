//a Imports
use crate::Bezier;
use crate::{BezierSplit, DynBezier};
use geo_nd::{Float, Num};

/// An iterator with Item = (V, V) of straight lines that form a single Bezier curve
///
/// An iteration will provide (Pa, Pb) pairs of points, with
/// the next iteration providing (Pb, Pc), then (Pc, Pd), etc;
/// sharing the end/start points.
///
/// This iterator is generated by the [crate::Bezier::as_lines] method
#[derive(Clone)]
pub struct BezierLineIter<F: Num, B: BezierSplit + DynBezier<F> + Clone> {
    /// Maximum curviness of the line segments returned
    straightness: F,
    /// A stack of future beziers to examine
    /// The top of the stack is p0->p1; below that is p1->p2, etc
    /// These beziers will need to be split to achieve the maximum
    /// curviness
    stack: Vec<B>,
}

//pi BezierLineIter
impl<F, B> BezierLineIter<F, B>
where
    F: Num,
    B: BezierSplit + DynBezier<F> + Clone,
{
    //fp new
    /// Create a new Bezier line iterator for a given Bezier and
    /// straightness
    ///
    /// This clones the Bezier.
    pub fn new(bezier: &B, straightness: F) -> Self {
        let stack = vec![bezier.clone()];
        Self {
            straightness,
            stack,
        }
    }

    //mp restart
    /// Clear the Bezier line iterator and restart with a new Bezier and
    /// straightness
    ///
    /// This clones the Bezier.
    pub fn restart(&mut self, bezier: &B, straightness: F) {
        self.straightness = straightness;
        self.stack.clear();
        self.stack.push(bezier.clone());
    }

    //zz All done
}

//ip Iterator for BezierLineIter
impl<F, B> std::iter::Iterator for BezierLineIter<F, B>
where
    F: Num,
    B: BezierSplit + DynBezier<F> + Clone,
{
    /// Item is a pair of points that make a straight line
    type Item = (B::Point, B::Point);
    /// next - return None or Some(pa,pb)
    ///
    /// It pops the first Bezier from the stack: this is (pa,px); if
    /// this is straight enough then return it, else split it in two
    /// (pa,pm), (pm,px) and push them in reverse order, then recurse.
    ///
    /// This forces the segment returned (eventually!) to be (pa,pb)
    /// and to leave the top of the stack starting with pb.
    fn next(&mut self) -> Option<Self::Item> {
        match self.stack.pop() {
            None => None,
            Some(b) => {
                if b.is_straight(self.straightness) {
                    Some(b.endpoints())
                } else {
                    let (b0, b1) = b.bisect();
                    self.stack.push(b1);
                    self.stack.push(b0);
                    self.next()
                }
            }
        }
    }

    //zz All done
}
